Ce fichier sert à expliquer chaque étape du jeu réalisée. Ca permet de 
comprendre le code source et ça sera utile pour le rapport du projet
de fin de semestre. Ne rien écrire là-dedans, mais on peut s'inspirer de ce fichier
pour écrire le rapport.

* Affichage de la carte :
Le niveau est écrit dans carte.txt, chaque chiffre correspond à un élément de
la carte. Dans lireFichier(), on lit chaque chiffre et on
remplit la carte 2D qui nous sera utile dans tout le programme.
Dans la carte peuvent se trouver uniquement : murs, briques, vide, items
(flamme+, bombe+, roller etc...), flammes causées par les bombes. 
Les personnages ne sont pas présents dans la carte, 
on préfère repérer leurs positions en pixels en créant des variables SDL_Rect.




* POSE DE BOMBE :

Chaque joueur a un nombre total de bombes à la base, et un nombre de bombes
restantes (2 variables différentes).
Pour chaque joueur, on vérifie si la touche de pose de bombe a été appuyée dans la boucle de jeu.
Si oui, on vérifie si il lui reste au moins 1 bombe et si la touche d'appui de bombe
n'était pas déjà appuyée à l'instant t-1 (très important ! On veut qu'il ne puisse poser
qu'une seule bombe à la fois, même si il reste appuyé).
Si les conditions sont vérifiées, on appelle la
fonction poserBombe().





* EXPLOSION DE BOMBE :

1) On vérifie à la fin de la boucle des événements si la première
bombe posée par chaque joueur peut exploser, dans verifierDelai().

Si la fn renvoie 1, on fait exploser la bombe grâce à exploserBombe():
Ajout de la bombe explosée dans la liste bombesExplosees et parallèlement
suppression de la bombe de la liste bombesPosees. 
Détermination de la portée de la bombe dans determinerPortee()  puis
affichage de l'explosion sur la carte grâce à afficherExplosion().


* Affichage de l'explosion :

Pour l'affichage de l'explosion, c'est une question 
de délai (l'explosion doit être visible pendant DELAI_FLAMME millisecondes).
A chaque fois qu'une bombe explose, on enregistre sa position 
sur la carte et sa portée dans une liste chaînée de bombes 
qui ont explosé, bombesExplosees.
Dans la boucle principale de jeu, on vérifie pour l'ensemble de cette liste
si le délai est respecté dans verifierDelai(). Si oui, on efface l'explosion
grâce à afficherExplosion().


* Conséquences de la bombe :

- Cassage des briques : Au moment de la détermination de la portée, dans
determinerPortee():
la flamme parcoure le terrain et s'arrêtera si elle rencontre une brique. 
Si oui, dans un tableau de 4 briques (pour chaque direction) dans la 
classe brique de la structure Maillon, on attribue 
la valeur 1 à la direction donnée, ça veut dire que cette bombe va casser
une brique dans cette direction.
On note la position de la brique à casser. Dans jouerPartie(), au moment où on
détermine l'explosion des flammes, on vérifie aussi si des briques doivent
être cassées dans casserBrique(). Voilà.

- Explosion d'une autre bombe sur son passage : 
Dans determinerPortee(), si la flamme rencontre une bombe, elle détecte sa position
dans bombesPosees grâce à chercherBombe(). Cette bombe, on change son instant pour faire
en sorte qu'elle explose quand on la vérifie, et on la positionne au rang 1 dans
bombesPosees pour que ce soit la prochaine à être vérifiéen dans entrainerExplosion(). 


- Tuer un joueur :
Idée : On a défini la hitbox. Tant que des flammes ou des items
sont présents
sur le terrain, on définit pour chaque joueur la position sur la
carte de chacun des coins de la hitbox. Pour chaque coin on regarde
si, sur la carte, le coin est présent sur une flamme.
Si oui, le joueur est mort.


-Brûler des items : ça fonctionne déjà, lorsqu'elle rencontre un item elle
l'écrase en posant sa FLAMME



* COLLISIONS (mus le gay)

Lorsque le joueur cherche à aller dans une direction,
on vérifie les positions sur la carte des 2 coins 
considérés si le joueur avait
avancé. S'il n'y a ni brique ni mur aux
positions des 2 coins considérés, alors le joueur peut avancer,
on renvoie la valeur correspondante.

PAS FINI : SI LE JOUEUR PEUT AVANCER, ON DOIT REGARDER
CE QU'IL SE TROUVE SUR CETTE POSITION ET AGIR EN FONCTION
(ITEM, BOMBE ETC)

* DEPLACEMENT DU JOUEUR

Si le joueur a le droit de se déplacer dans la direction
demandée, on fait avancer la hitbox de tant de pixels selon la
vitesse du perso, et on redéfinit les positions sur la carte
de chaque coin de la hitbox. Voilà.



* LES ITEMS

- Génération d'items

On choisit de répartir n items sur la carte, dans des briques.
On génère aléatoirement n positions, en vérifiant que des
briques sont situées à ces positions (sinon on recommence),
dans une liste chaînée d'items. Chaque case de la liste contient
les positions de l'item et son type (roller, flamme, bombe etc).

Au moment du cassage d'une brique (voir où ça se trouve),
au lieu de remplacer cette brique par du vide, on parcoure la
liste pour vérifier si cette brique est à la même position
qu'un item. Si oui, on remplace la brique par cet item.


- Prendre un item

Dans vérifierCollision(), lorsqu'au moins un item est présent
sur le terrain, on regarde les positions des 4 coins de
chaque joueur. Si un des coins est positionné sur un item,
alors selon l'item on lui attribue le boost récupéré.
Comment savoir si un item est présent sur le terrain ?
A chaque fois qu'un item est découvert par une brique,
on incrémente la classe nbItemsSurTerrain située dans la
variable qui est le nom de la liste (la variable qui
permet d'accéder aux éléments de la liste).
Du coup tant que nbItemsSurTerrain est non nul, on vérifie les
coins des joueurs.


